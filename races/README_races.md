# Проект базы данных автомобильных гонок

## Обзор проекта

Этот проект реализует SQL базу данных для хранения и управления информацией о гонках, автомобилях и их результатах. База данных разработана для демонстрации навыков SQL, включая создание таблиц, определение связей, вставку данных и выполнение сложных запросов с использованием оконных функций, подзапросов и агрегации.

## Цели проекта

- Создать нормализованную схему базы данных для хранения информации о гонках и автомобилях
- Реализовать связи между автомобилями, классами автомобилей, гонками и результатами
- Продемонстрировать возможности SQL-запросов для анализа производительности автомобилей в гонках
- Показать использование оконных функций, CTE (Common Table Expressions) и агрегатных функций для сложного анализа данных

## Структура базы данных

База данных состоит из четырех основных таблиц:

### 1. Таблица Classes (Классы автомобилей)

Хранит информацию о различных классах автомобилей:

- `class`: Название класса автомобиля (первичный ключ)
- `type`: Тип класса (Racing или Street)
- `country`: Страна происхождения класса
- `numDoors`: Количество дверей
- `engineSize`: Объем двигателя в литрах
- `weight`: Вес автомобиля в килограммах

### 2. Таблица Cars (Автомобили)

Хранит информацию об автомобилях:

- `name`: Название автомобиля (первичный ключ)
- `class`: Внешний ключ, ссылающийся на таблицу Classes
- `year`: Год выпуска автомобиля

### 3. Таблица Races (Гонки)

Хранит информацию о гонках:

- `name`: Название гонки (первичный ключ)
- `date`: Дата проведения гонки

### 4. Таблица Results (Результаты)

Хранит информацию о результатах автомобилей в гонках:

- `car`: Внешний ключ, ссылающийся на таблицу Cars (часть составного первичного ключа)
- `race`: Внешний ключ, ссылающийся на таблицу Races (часть составного первичного ключа)
- `position`: Позиция автомобиля в гонке

## Связи между сущностями

- Каждый автомобиль принадлежит к определенному классу (связь Cars и Classes)
- Каждый автомобиль может участвовать в нескольких гонках
- Каждая гонка может включать несколько автомобилей
- Таблица Results представляет связь многие-ко-многим между автомобилями и гонками

## Реализованная функциональность

### Инициализация базы данных (init.sql)

- Создание таблиц с соответствующими ограничениями
- Вставка примеров данных для классов автомобилей, автомобилей, гонок и результатов

### Запрос 1: Автомобили с наименьшей средней позицией в каждом классе (1.sql)

Этот запрос определяет, какие автомобили из каждого класса имеют наименьшую среднюю позицию в гонках, и выводит информацию о каждом таком автомобиле, включая его класс, среднюю позицию и количество гонок, в которых он участвовал. Результаты отсортированы по средней позиции.

```sql
WITH AveragePositions AS (
    -- Вычисляем среднюю позицию и количество гонок для каждого автомобиля
    SELECT c.name          AS car_name,
           c.class,
           AVG(r.position) AS avg_position,
           COUNT(r.race)   AS race_count
    FROM Cars c
             JOIN
         Results r ON c.name = r.car
    GROUP BY c.name, c.class),
     RankedCars AS (
         -- Ранжируем автомобили в каждом классе по средней позиции
         SELECT car_name,
                class,
                avg_position,
                race_count,
                RANK() OVER (PARTITION BY class ORDER BY avg_position) AS position_rank
         FROM AveragePositions)
-- Выбираем автомобили с наименьшей средней позицией в каждом классе
SELECT class,
       car_name,
       avg_position,
       race_count
FROM RankedCars
WHERE position_rank = 1
ORDER BY avg_position;
```

Этот запрос использует Common Table Expressions (CTE) и оконную функцию RANK() для ранжирования автомобилей в каждом классе по их средней позиции в гонках. Затем выбираются только автомобили с рангом 1 (наименьшая средняя позиция) в каждом классе.

### Запрос 2: Автомобиль с наименьшей средней позицией (2.sql)

Этот запрос определяет автомобиль, который имеет наименьшую среднюю позицию в гонках среди всех автомобилей, и выводит информацию об этом автомобиле, включая его класс, среднюю позицию, количество гонок, в которых он участвовал, и страну производства класса автомобиля.

```sql
SELECT c.name          AS car_name,
       c.class,
       cl.country      AS class_country,
       AVG(r.position) AS avg_position,
       COUNT(r.race)   AS race_count
FROM Cars c
         JOIN
     Results r ON c.name = r.car
         JOIN
     Classes cl ON c.class = cl.class
GROUP BY c.name, c.class, cl.country
ORDER BY AVG(r.position), c.name
LIMIT 1;
```

Этот запрос объединяет таблицы Cars, Results и Classes, группирует результаты по автомобилю, классу и стране, вычисляет среднюю позицию и количество гонок для каждого автомобиля, сортирует результаты по средней позиции и имени автомобиля, и выбирает только первую запись (автомобиль с наименьшей средней позицией).

### Запрос 3: Автомобили из классов с наименьшей средней позицией (3.sql)

Этот запрос определяет классы автомобилей, которые имеют наименьшую среднюю позицию в гонках, и выводит информацию о каждом автомобиле из этих классов, включая его имя, среднюю позицию, количество гонок, в которых он участвовал, страну производства класса автомобиля, а также общее количество гонок, в которых участвовали автомобили этих классов.

```sql
WITH ClassAvgPositions AS (
    -- Вычисляем среднюю позицию для каждого класса автомобилей
    SELECT cl.class,
           cl.country,
           AVG(r.position)        AS avg_position,
           COUNT(DISTINCT r.race) AS total_races
    FROM Classes cl
             JOIN
         Cars c ON cl.class = c.class
             JOIN
         Results r ON c.name = r.car
    GROUP BY cl.class, cl.country),
     MinAvgPosition AS (
         -- Находим минимальную среднюю позицию среди всех классов
         SELECT MIN(avg_position) AS min_avg_position
         FROM ClassAvgPositions)

-- Выбираем информацию о каждом автомобиле из классов с наименьшей средней позицией
SELECT c.name          AS car_name,
       AVG(r.position) AS avg_position,
       COUNT(r.race)   AS race_count,
       cl.country      AS class_country,
       cap.total_races AS class_total_races
FROM Cars c
         JOIN
     Results r ON c.name = r.car
         JOIN
     Classes cl ON c.class = cl.class
         JOIN
     ClassAvgPositions cap ON cl.class = cap.class
         JOIN
     MinAvgPosition map ON cap.avg_position = map.min_avg_position
GROUP BY c.name, cl.country, cap.total_races
ORDER BY AVG(r.position), c.name;
```

Этот запрос использует несколько CTE для вычисления средней позиции для каждого класса автомобилей, нахождения минимальной средней позиции среди всех классов, и затем выбора информации о каждом автомобиле из классов с наименьшей средней позицией.

### Запрос 4: Автомобили с позицией лучше средней в своем классе (4.sql)

Этот запрос определяет, какие автомобили имеют среднюю позицию лучше (меньше) средней позиции всех автомобилей в своем классе, и выводит информацию об этих автомобилях, включая их имя, класс, среднюю позицию, количество гонок, в которых они участвовали, и страну производства класса автомобиля.

```sql
WITH CarAvgPositions AS (
    -- Вычисляем среднюю позицию для каждого автомобиля
    SELECT c.name,
           c.class,
           AVG(r.position) AS avg_position,
           COUNT(r.race)   AS race_count
    FROM Cars c
             JOIN
         Results r ON c.name = r.car
    GROUP BY c.name, c.class),
     ClassAvgPositions AS (
         -- Вычисляем среднюю позицию для каждого класса и количество автомобилей в классе
         SELECT c.class,
                AVG(r.position)        AS class_avg_position,
                COUNT(DISTINCT c.name) AS car_count
         FROM Cars c
                  JOIN
              Results r ON c.name = r.car
         GROUP BY c.class)

-- Выбираем автомобили с позицией лучше средней в своем классе
SELECT cap.name   AS car_name,
       cap.class,
       cap.avg_position,
       cap.race_count,
       cl.country AS class_country
FROM CarAvgPositions cap
         JOIN
     ClassAvgPositions clap ON cap.class = clap.class
         JOIN
     Classes cl ON cap.class = cl.class
WHERE cap.avg_position < clap.class_avg_position -- Позиция лучше (меньше) средней в классе
  AND clap.car_count >= 2                        -- В классе минимум два автомобиля
ORDER BY cap.class,
         cap.avg_position;
```

Этот запрос использует CTE для вычисления средней позиции для каждого автомобиля и средней позиции для каждого класса автомобилей, а затем выбирает автомобили, у которых средняя позиция лучше (меньше) средней позиции в их классе, при условии, что в классе есть минимум два автомобиля.

### Запрос 5: Классы с наибольшим количеством автомобилей с низкой производительностью (5.sql)

Этот запрос определяет, какие классы автомобилей имеют наибольшее количество автомобилей с низкой средней позицией (больше 3.0), и выводит информацию о каждом автомобиле из этих классов, включая его имя, класс, среднюю позицию, количество гонок, в которых он участвовал, страну производства класса автомобиля, а также общее количество гонок для каждого класса.

```sql
WITH CarAvgPositions AS (
    -- Вычисляем среднюю позицию для каждого автомобиля и количество гонок
    SELECT c.name,
           c.class,
           AVG(r.position) AS avg_position,
           COUNT(r.race)   AS race_count
    FROM Cars c
             JOIN
         Results r ON c.name = r.car
    GROUP BY c.name, c.class),
     PoorPerformanceCars AS (
         -- Фильтруем автомобили с низкой средней позицией (больше 3.0)
         SELECT name,
                class,
                avg_position,
                race_count
         FROM CarAvgPositions
         WHERE avg_position > 3),
     CarsWithPoorPerformance AS (
         -- Подсчитываем количество автомобилей с низкой производительностью в каждом классе
         SELECT class,
                COUNT(*) AS poor_performance_cars_count
         FROM PoorPerformanceCars
         GROUP BY class),
     ClassRaceCounts AS (
         -- Подсчитываем общее количество гонок для каждого класса
         SELECT c.class,
                COUNT(DISTINCT r.race) AS total_races
         FROM Cars c
                  JOIN
              Results r ON c.name = r.car
         GROUP BY c.class)

-- Основной запрос
SELECT ppc.name        AS car_name,
       ppc.class,
       ppc.avg_position,
       ppc.race_count,
       cl.country      AS class_country,
       crc.total_races AS class_total_races
FROM PoorPerformanceCars ppc
         JOIN
     CarsWithPoorPerformance cwpp ON ppc.class = cwpp.class
         JOIN
     Classes cl ON ppc.class = cl.class
         JOIN
     ClassRaceCounts crc ON ppc.class = crc.class
ORDER BY cwpp.poor_performance_cars_count DESC,
         ppc.class,
         ppc.avg_position;
```

Этот запрос использует несколько CTE для вычисления средней позиции для каждого автомобиля, фильтрации автомобилей с низкой производительностью (средняя позиция больше 3.0), подсчета количества таких автомобилей в каждом классе, и подсчета общего количества гонок для каждого класса. Затем выбирается информация о каждом автомобиле с низкой производительностью, и результаты сортируются по количеству автомобилей с низкой производительностью в каждом классе в порядке убывания.

## Инструкции по запуску и тестированию

### Предварительные требования

- Любая система управления базами данных SQL (PostgreSQL, MySQL, SQLite и т.д.)
- SQL-клиент или интерфейс командной строки

### Шаги настройки

1. Создайте новую базу данных (если требуется вашей системой управления базами данных)
2. Запустите скрипт инициализации:
   ```
   psql -d your_database -f races/init.sql
   ```
   или эквивалентную команду для вашей системы управления базами данных

3. Проверьте, что данные были вставлены правильно:
   ```sql
   SELECT * FROM Classes;
   SELECT * FROM Cars;
   SELECT * FROM Races;
   SELECT * FROM Results;
   ```

### Запуск запросов

1. Для запуска запроса о автомобилях с наименьшей средней позицией в каждом классе:
   ```
   psql -d your_database -f races/1.sql
   ```

2. Для запуска запроса о автомобиле с наименьшей средней позицией:
   ```
   psql -d your_database -f races/2.sql
   ```

3. Для запуска запроса о автомобилях из классов с наименьшей средней позицией:
   ```
   psql -d your_database -f races/3.sql
   ```

4. Для запуска запроса о автомобилях с позицией лучше средней в своем классе:
   ```
   psql -d your_database -f races/4.sql
   ```

5. Для запуска запроса о классах с наибольшим количеством автомобилей с низкой производительностью:
   ```
   psql -d your_database -f races/5.sql
   ```

### Тестирование

Вы можете протестировать базу данных следующими способами:

1. Добавление новых автомобилей, классов, гонок и результатов и проверка ограничений
2. Изменение запросов для проверки различных критериев фильтрации и агрегации
3. Создание собственных запросов для анализа производительности автомобилей в гонках
